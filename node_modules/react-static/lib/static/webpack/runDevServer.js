"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = runDevServer;
exports.reloadClientData = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _webpack = _interopRequireDefault(require("webpack"));

var _chalk = _interopRequireDefault(require("chalk"));

var _socket = _interopRequireDefault(require("socket.io"));

var _webpackDevServer = _interopRequireDefault(require("webpack-dev-server"));

var _makeWebpackConfig = _interopRequireDefault(require("./makeWebpackConfig"));

var _getRouteData = _interopRequireDefault(require("../getRouteData"));

var _plugins = _interopRequireDefault(require("../plugins"));

var _utils = require("../../utils");

var _fetchSiteData = _interopRequireDefault(require("../fetchSiteData"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var devServer;
var latestState;

var buildDevRoutes = function buildDevRoutes() {};

var reloadClientData = function reloadClientData() {
  if (reloadClientData.current) {
    reloadClientData.current();
  }
}; // Starts the development server


exports.reloadClientData = reloadClientData;

function runDevServer(_x) {
  return _runDevServer.apply(this, arguments);
}

function _runDevServer() {
  _runDevServer = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee(state) {
    return _regenerator["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!devServer) {
              _context.next = 7;
              break;
            }

            _context.next = 3;
            return buildDevRoutes(state);

          case 3:
            _context.next = 5;
            return reloadClientData();

          case 5:
            _context.next = 10;
            break;

          case 7:
            _context.next = 9;
            return runExpressServer(state);

          case 9:
            state = _context.sent;

          case 10:
            return _context.abrupt("return", state);

          case 11:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _runDevServer.apply(this, arguments);
}

function runExpressServer(_x2) {
  return _runExpressServer.apply(this, arguments);
}

function _runExpressServer() {
  _runExpressServer = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee7(state) {
    var intendedPort, port, messagePort, devConfig, devCompiler, devServerConfig, first, startedAt, skipLog, socket;
    return _regenerator["default"].wrap(function _callee7$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            // Default to localhost:3000, or use a custom combo if defined in static.config.js
            // or environment variables
            intendedPort = Number(state.config.devServer.port);
            _context7.next = 3;
            return (0, _utils.findAvailablePort)(intendedPort);

          case 3:
            port = _context7.sent;
            _context7.next = 6;
            return (0, _utils.findAvailablePort)(4000, [port]);

          case 6:
            messagePort = _context7.sent;

            if (intendedPort !== port) {
              console.log(_chalk["default"].red("Warning! Port ".concat(intendedPort, " is not available. Using port ").concat(_chalk["default"].green(port), " instead!")));
            }

            state = _objectSpread({}, state, {
              config: _objectSpread({}, state.config, {
                devServer: _objectSpread({}, state.config.devServer, {
                  port: port
                })
              })
            });
            devConfig = (0, _makeWebpackConfig["default"])(state);
            devCompiler = (0, _webpack["default"])(devConfig);
            devServerConfig = _objectSpread({
              contentBase: [state.config.paths.PUBLIC, state.config.paths.DIST],
              publicPath: '/',
              historyApiFallback: true,
              compress: false,
              clientLogLevel: 'warning',
              overlay: true,
              stats: 'errors-only',
              noInfo: true
            }, state.config.devServer, {
              hotOnly: true,
              watchOptions: _objectSpread({}, state.config.devServer ? state.config.devServer.watchOptions || {} : {}, {
                ignored: [/node_modules/].concat((0, _toConsumableArray2["default"])((state.config.devServer.watchOptions || {}).ignored || []))
              }),
              before: function before(app) {
                // Serve the site data
                app.get('/__react-static__/getMessagePort',
                /*#__PURE__*/
                function () {
                  var _ref = (0, _asyncToGenerator2["default"])(
                  /*#__PURE__*/
                  _regenerator["default"].mark(function _callee2(req, res) {
                    return _regenerator["default"].wrap(function _callee2$(_context2) {
                      while (1) {
                        switch (_context2.prev = _context2.next) {
                          case 0:
                            res.send({
                              port: messagePort
                            });

                          case 1:
                          case "end":
                            return _context2.stop();
                        }
                      }
                    }, _callee2);
                  }));

                  return function (_x3, _x4) {
                    return _ref.apply(this, arguments);
                  };
                }()); // Since routes may change during dev, this function can rebuild all of the config
                // routes. It also references the original config when possible, to make sure it
                // uses any up to date getData callback generated from new or replacement routes.

                buildDevRoutes =
                /*#__PURE__*/
                function () {
                  var _ref2 = (0, _asyncToGenerator2["default"])(
                  /*#__PURE__*/
                  _regenerator["default"].mark(function _callee5(newState) {
                    return _regenerator["default"].wrap(function _callee5$(_context5) {
                      while (1) {
                        switch (_context5.prev = _context5.next) {
                          case 0:
                            _context5.next = 2;
                            return (0, _fetchSiteData["default"])(newState);

                          case 2:
                            latestState = _context5.sent;
                            app.get('/__react-static__/siteData',
                            /*#__PURE__*/
                            function () {
                              var _ref3 = (0, _asyncToGenerator2["default"])(
                              /*#__PURE__*/
                              _regenerator["default"].mark(function _callee3(req, res, next) {
                                return _regenerator["default"].wrap(function _callee3$(_context3) {
                                  while (1) {
                                    switch (_context3.prev = _context3.next) {
                                      case 0:
                                        try {
                                          res.send(latestState.siteData);
                                        } catch (err) {
                                          res.status(500);
                                          res.send(err);
                                          next(err);
                                        }

                                      case 1:
                                      case "end":
                                        return _context3.stop();
                                    }
                                  }
                                }, _callee3);
                              }));

                              return function (_x6, _x7, _x8) {
                                return _ref3.apply(this, arguments);
                              };
                            }()); // Serve each routes data

                            latestState.routes.forEach(function (_ref4) {
                              var routePath = _ref4.path;
                              app.get("/__react-static__/routeInfo/".concat(encodeURI(routePath === '/' ? '' : routePath)),
                              /*#__PURE__*/
                              function () {
                                var _ref5 = (0, _asyncToGenerator2["default"])(
                                /*#__PURE__*/
                                _regenerator["default"].mark(function _callee4(req, res, next) {
                                  var route, err;
                                  return _regenerator["default"].wrap(function _callee4$(_context4) {
                                    while (1) {
                                      switch (_context4.prev = _context4.next) {
                                        case 0:
                                          // Make sure we have the most up to date route from the config, not
                                          // an out of dat object.
                                          route = latestState.routes.find(function (d) {
                                            return d.path === routePath;
                                          });
                                          _context4.prev = 1;

                                          if (route) {
                                            _context4.next = 6;
                                            break;
                                          }

                                          err = new Error("Route could not be found for: ".concat(routePath, "\n                    \nIf you removed this route, disregard this error.\nIf this is a dynamic route, consider adding it to the prefetchExcludes list:\n\n  addPrefetchExcludes(['").concat(routePath, "'])\n"));
                                          delete err.stack;
                                          throw err;

                                        case 6:
                                          _context4.next = 8;
                                          return (0, _getRouteData["default"])(route, latestState);

                                        case 8:
                                          route = _context4.sent;
                                          // Don't use any hashProp, just pass all the data in dev
                                          res.json(route);
                                          _context4.next = 16;
                                          break;

                                        case 12:
                                          _context4.prev = 12;
                                          _context4.t0 = _context4["catch"](1);
                                          res.status(404);
                                          next(_context4.t0);

                                        case 16:
                                        case "end":
                                          return _context4.stop();
                                      }
                                    }
                                  }, _callee4, null, [[1, 12]]);
                                }));

                                return function (_x9, _x10, _x11) {
                                  return _ref5.apply(this, arguments);
                                };
                              }());
                            });
                            return _context5.abrupt("return", new Promise(function (resolve) {
                              return setTimeout(resolve, 1);
                            }));

                          case 6:
                          case "end":
                            return _context5.stop();
                        }
                      }
                    }, _callee5);
                  }));

                  return function buildDevRoutes(_x5) {
                    return _ref2.apply(this, arguments);
                  };
                }();

                buildDevRoutes(state);

                if (state.config.devServer && state.config.devServer.before) {
                  state.config.devServer.before(app);
                }

                return app;
              }
            });
            first = true;
            startedAt = Date.now();
            skipLog = false;
            console.log('Bundling Application...');
            (0, _utils.time)(_chalk["default"].green("[\u2713] Application Bundled"));
            devCompiler.hooks.invalid.tap({
              name: 'React-Static'
            }, function (file, changed) {
              // If a file is changed within the first two seconds of
              // the server starting, we don't bark about it. Less
              // noise is better!
              skipLog = changed - startedAt < 2000;

              if (!skipLog) {
                console.log('File changed:', file.replace(state.config.paths.ROOT, ''));
                console.log('Updating bundle...');
                (0, _utils.time)(_chalk["default"].green("[\u2713] Bundle Updated"));
              }
            });
            devCompiler.hooks.done.tap({
              name: 'React-Static'
            }, function (stats) {
              var messages = stats.toJson({}, true);
              var isSuccessful = !messages.errors.length && !messages.warnings.length;

              if (isSuccessful && !skipLog) {
                if (first) {
                  (0, _utils.timeEnd)(_chalk["default"].green("[\u2713] Application Bundled"));
                  console.log("".concat(_chalk["default"].green("[\u2713] App serving at"), " ").concat(_chalk["default"].blue("".concat(state.config.devServer.host, ":").concat(state.config.devServer.port))));
                } else {
                  (0, _utils.timeEnd)(_chalk["default"].green("[\u2713] Bundle Updated"));
                }
              }

              first = false;
            }); // Start the webpack dev server

            devServer = new _webpackDevServer["default"](devCompiler, devServerConfig); // Start the messages socket

            socket = (0, _socket["default"])();
            reloadClientData.current =
            /*#__PURE__*/
            (0, _asyncToGenerator2["default"])(
            /*#__PURE__*/
            _regenerator["default"].mark(function _callee6() {
              return _regenerator["default"].wrap(function _callee6$(_context6) {
                while (1) {
                  switch (_context6.prev = _context6.next) {
                    case 0:
                      socket.emit('message', {
                        type: 'reloadClientData'
                      });

                    case 1:
                    case "end":
                      return _context6.stop();
                  }
                }
              }, _callee6);
            }));
            _context7.next = 24;
            return new Promise(function (resolve, reject) {
              devServer.listen(port, null, function (err) {
                if (err) {
                  return reject(err);
                }

                resolve();
              });
            });

          case 24:
            // Make sure we start listening on the message port after the dev server.
            // We do this mostly to appease codesandbox.io, since they autobind to the first
            // port that opens up for their preview window.
            socket.listen(messagePort);
            _context7.next = 27;
            return _plugins["default"].afterDevServerStart(state);

          case 27:
            state = _context7.sent;
            return _context7.abrupt("return", state);

          case 29:
          case "end":
            return _context7.stop();
        }
      }
    }, _callee7);
  }));
  return _runExpressServer.apply(this, arguments);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9zdGF0aWMvd2VicGFjay9ydW5EZXZTZXJ2ZXIuanMiXSwibmFtZXMiOlsiZGV2U2VydmVyIiwibGF0ZXN0U3RhdGUiLCJidWlsZERldlJvdXRlcyIsInJlbG9hZENsaWVudERhdGEiLCJjdXJyZW50IiwicnVuRGV2U2VydmVyIiwic3RhdGUiLCJydW5FeHByZXNzU2VydmVyIiwiaW50ZW5kZWRQb3J0IiwiTnVtYmVyIiwiY29uZmlnIiwicG9ydCIsIm1lc3NhZ2VQb3J0IiwiY29uc29sZSIsImxvZyIsImNoYWxrIiwicmVkIiwiZ3JlZW4iLCJkZXZDb25maWciLCJkZXZDb21waWxlciIsImRldlNlcnZlckNvbmZpZyIsImNvbnRlbnRCYXNlIiwicGF0aHMiLCJQVUJMSUMiLCJESVNUIiwicHVibGljUGF0aCIsImhpc3RvcnlBcGlGYWxsYmFjayIsImNvbXByZXNzIiwiY2xpZW50TG9nTGV2ZWwiLCJvdmVybGF5Iiwic3RhdHMiLCJub0luZm8iLCJob3RPbmx5Iiwid2F0Y2hPcHRpb25zIiwiaWdub3JlZCIsImJlZm9yZSIsImFwcCIsImdldCIsInJlcSIsInJlcyIsInNlbmQiLCJuZXdTdGF0ZSIsIm5leHQiLCJzaXRlRGF0YSIsImVyciIsInN0YXR1cyIsInJvdXRlcyIsImZvckVhY2giLCJyb3V0ZVBhdGgiLCJwYXRoIiwiZW5jb2RlVVJJIiwicm91dGUiLCJmaW5kIiwiZCIsIkVycm9yIiwic3RhY2siLCJqc29uIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwiZmlyc3QiLCJzdGFydGVkQXQiLCJEYXRlIiwibm93Iiwic2tpcExvZyIsImhvb2tzIiwiaW52YWxpZCIsInRhcCIsIm5hbWUiLCJmaWxlIiwiY2hhbmdlZCIsInJlcGxhY2UiLCJST09UIiwiZG9uZSIsIm1lc3NhZ2VzIiwidG9Kc29uIiwiaXNTdWNjZXNzZnVsIiwiZXJyb3JzIiwibGVuZ3RoIiwid2FybmluZ3MiLCJibHVlIiwiaG9zdCIsIldlYnBhY2tEZXZTZXJ2ZXIiLCJzb2NrZXQiLCJlbWl0IiwidHlwZSIsInJlamVjdCIsImxpc3RlbiIsInBsdWdpbnMiLCJhZnRlckRldlNlcnZlclN0YXJ0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7Ozs7O0FBRUEsSUFBSUEsU0FBSjtBQUNBLElBQUlDLFdBQUo7O0FBQ0EsSUFBSUMsY0FBYyxHQUFHLDBCQUFNLENBQUUsQ0FBN0I7O0FBRU8sSUFBTUMsZ0JBQWdCLEdBQUcsU0FBbkJBLGdCQUFtQixHQUFNO0FBQ3BDLE1BQUlBLGdCQUFnQixDQUFDQyxPQUFyQixFQUE4QjtBQUM1QkQsSUFBQUEsZ0JBQWdCLENBQUNDLE9BQWpCO0FBQ0Q7QUFDRixDQUpNLEMsQ0FNUDs7Ozs7U0FDOEJDLFk7Ozs7Ozs7K0JBQWYsaUJBQTRCQyxLQUE1QjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsaUJBT1ROLFNBUFM7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQSxtQkFRTEUsY0FBYyxDQUFDSSxLQUFELENBUlQ7O0FBQUE7QUFBQTtBQUFBLG1CQVNMSCxnQkFBZ0IsRUFUWDs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBLG1CQVdHSSxnQkFBZ0IsQ0FBQ0QsS0FBRCxDQVhuQjs7QUFBQTtBQVdYQSxZQUFBQSxLQVhXOztBQUFBO0FBQUEsNkNBY05BLEtBZE07O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRzs7OztTQWlCQUMsZ0I7Ozs7Ozs7K0JBQWYsa0JBQWdDRCxLQUFoQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDRTtBQUNBO0FBQ01FLFlBQUFBLFlBSFIsR0FHdUJDLE1BQU0sQ0FBQ0gsS0FBSyxDQUFDSSxNQUFOLENBQWFWLFNBQWIsQ0FBdUJXLElBQXhCLENBSDdCO0FBQUE7QUFBQSxtQkFJcUIsOEJBQWtCSCxZQUFsQixDQUpyQjs7QUFBQTtBQUlRRyxZQUFB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QUFBQTtBQUFBO0FBQUEsRyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIGltcG9ydC9uby1keW5hbWljLXJlcXVpcmUsIHJlYWN0L25vLWRhbmdlciwgaW1wb3J0L25vLW11dGFibGUtZXhwb3J0cyAqL1xyXG5pbXBvcnQgd2VicGFjayBmcm9tICd3ZWJwYWNrJ1xyXG5pbXBvcnQgY2hhbGsgZnJvbSAnY2hhbGsnXHJcbmltcG9ydCBpbyBmcm9tICdzb2NrZXQuaW8nXHJcbmltcG9ydCBXZWJwYWNrRGV2U2VydmVyIGZyb20gJ3dlYnBhY2stZGV2LXNlcnZlcidcclxuLy9cclxuaW1wb3J0IG1ha2VXZWJwYWNrQ29uZmlnIGZyb20gJy4vbWFrZVdlYnBhY2tDb25maWcnXHJcbmltcG9ydCBnZXRSb3V0ZURhdGEgZnJvbSAnLi4vZ2V0Um91dGVEYXRhJ1xyXG5pbXBvcnQgcGx1Z2lucyBmcm9tICcuLi9wbHVnaW5zJ1xyXG5pbXBvcnQgeyBmaW5kQXZhaWxhYmxlUG9ydCwgdGltZSwgdGltZUVuZCB9IGZyb20gJy4uLy4uL3V0aWxzJ1xyXG5pbXBvcnQgZmV0Y2hTaXRlRGF0YSBmcm9tICcuLi9mZXRjaFNpdGVEYXRhJ1xyXG5cclxubGV0IGRldlNlcnZlclxyXG5sZXQgbGF0ZXN0U3RhdGVcclxubGV0IGJ1aWxkRGV2Um91dGVzID0gKCkgPT4ge31cclxuXHJcbmV4cG9ydCBjb25zdCByZWxvYWRDbGllbnREYXRhID0gKCkgPT4ge1xyXG4gIGlmIChyZWxvYWRDbGllbnREYXRhLmN1cnJlbnQpIHtcclxuICAgIHJlbG9hZENsaWVudERhdGEuY3VycmVudCgpXHJcbiAgfVxyXG59XHJcblxyXG4vLyBTdGFydHMgdGhlIGRldmVsb3BtZW50IHNlcnZlclxyXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBydW5EZXZTZXJ2ZXIoc3RhdGUpIHtcclxuICAvLyBUT0RPIGNoZWNrIGNvbmZpZy5kZXZTZXJ2ZXIgZm9yIGNoYW5nZXMgYW5kIG5vdGlmeSB1c2VyXHJcbiAgLy8gaWYgdGhlIHNlcnZlciBuZWVkcyB0byBiZSByZXN0YXJ0ZWQgZm9yIGNoYW5nZXMgdG8gdGFrZVxyXG4gIC8vIGVmZmVjdC5cclxuXHJcbiAgLy8gSWYgdGhlIHNlcnZlciBpcyBhbHJlYWR5IHJ1bm5pbmcsIHRyaWdnZXIgYSByZWZyZXNoIHRvIHRoZSBjbGllbnRcclxuXHJcbiAgaWYgKGRldlNlcnZlcikge1xyXG4gICAgYXdhaXQgYnVpbGREZXZSb3V0ZXMoc3RhdGUpXHJcbiAgICBhd2FpdCByZWxvYWRDbGllbnREYXRhKClcclxuICB9IGVsc2Uge1xyXG4gICAgc3RhdGUgPSBhd2FpdCBydW5FeHByZXNzU2VydmVyKHN0YXRlKVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHN0YXRlXHJcbn1cclxuXHJcbmFzeW5jIGZ1bmN0aW9uIHJ1bkV4cHJlc3NTZXJ2ZXIoc3RhdGUpIHtcclxuICAvLyBEZWZhdWx0IHRvIGxvY2FsaG9zdDozMDAwLCBvciB1c2UgYSBjdXN0b20gY29tYm8gaWYgZGVmaW5lZCBpbiBzdGF0aWMuY29uZmlnLmpzXHJcbiAgLy8gb3IgZW52aXJvbm1lbnQgdmFyaWFibGVzXHJcbiAgY29uc3QgaW50ZW5kZWRQb3J0ID0gTnVtYmVyKHN0YXRlLmNvbmZpZy5kZXZTZXJ2ZXIucG9ydClcclxuICBjb25zdCBwb3J0ID0gYXdhaXQgZmluZEF2YWlsYWJsZVBvcnQoaW50ZW5kZWRQb3J0KVxyXG5cclxuICAvLyBGaW5kIGFuIGF2YWlsYWJsZSBwb3J0IGZvciBtZXNzYWdlcywgYXMgbG9uZyBhcyBpdCdzIG5vdCB0aGUgZGV2U2VydmVyIHBvcnRcclxuICBjb25zdCBtZXNzYWdlUG9ydCA9IGF3YWl0IGZpbmRBdmFpbGFibGVQb3J0KDQwMDAsIFtwb3J0XSlcclxuXHJcbiAgaWYgKGludGVuZGVkUG9ydCAhPT0gcG9ydCkge1xyXG4gICAgY29uc29sZS5sb2coXHJcbiAgICAgIGNoYWxrLnJlZChcclxuICAgICAgICBgV2FybmluZyEgUG9ydCAke2ludGVuZGVkUG9ydH0gaXMgbm90IGF2YWlsYWJsZS4gVXNpbmcgcG9ydCAke2NoYWxrLmdyZWVuKFxyXG4gICAgICAgICAgcG9ydFxyXG4gICAgICAgICl9IGluc3RlYWQhYFxyXG4gICAgICApXHJcbiAgICApXHJcbiAgfVxyXG5cclxuICBzdGF0ZSA9IHtcclxuICAgIC4uLnN0YXRlLFxyXG4gICAgY29uZmlnOiB7XHJcbiAgICAgIC4uLnN0YXRlLmNvbmZpZyxcclxuICAgICAgZGV2U2VydmVyOiB7XHJcbiAgICAgICAgLi4uc3RhdGUuY29uZmlnLmRldlNlcnZlcixcclxuICAgICAgICBwb3J0LFxyXG4gICAgICB9LFxyXG4gICAgfSxcclxuICB9XHJcblxyXG4gIGNvbnN0IGRldkNvbmZpZyA9IG1ha2VXZWJwYWNrQ29uZmlnKHN0YXRlKVxyXG4gIGNvbnN0IGRldkNvbXBpbGVyID0gd2VicGFjayhkZXZDb25maWcpXHJcblxyXG4gIGNvbnN0IGRldlNlcnZlckNvbmZpZyA9IHtcclxuICAgIGNvbnRlbnRCYXNlOiBbc3RhdGUuY29uZmlnLnBhdGhzLlBVQkxJQywgc3RhdGUuY29uZmlnLnBhdGhzLkRJU1RdLFxyXG4gICAgcHVibGljUGF0aDogJy8nLFxyXG4gICAgaGlzdG9yeUFwaUZhbGxiYWNrOiB0cnVlLFxyXG4gICAgY29tcHJlc3M6IGZhbHNlLFxyXG4gICAgY2xpZW50TG9nTGV2ZWw6ICd3YXJuaW5nJyxcclxuICAgIG92ZXJsYXk6IHRydWUsXHJcbiAgICBzdGF0czogJ2Vycm9ycy1vbmx5JyxcclxuICAgIG5vSW5mbzogdHJ1ZSxcclxuICAgIC4uLnN0YXRlLmNvbmZpZy5kZXZTZXJ2ZXIsXHJcbiAgICBob3RPbmx5OiB0cnVlLFxyXG4gICAgd2F0Y2hPcHRpb25zOiB7XHJcbiAgICAgIC4uLihzdGF0ZS5jb25maWcuZGV2U2VydmVyXHJcbiAgICAgICAgPyBzdGF0ZS5jb25maWcuZGV2U2VydmVyLndhdGNoT3B0aW9ucyB8fCB7fVxyXG4gICAgICAgIDoge30pLFxyXG4gICAgICBpZ25vcmVkOiBbXHJcbiAgICAgICAgL25vZGVfbW9kdWxlcy8sXHJcblxyXG4gICAgICAgIC4uLigoc3RhdGUuY29uZmlnLmRldlNlcnZlci53YXRjaE9wdGlvbnMgfHwge30pLmlnbm9yZWQgfHwgW10pLFxyXG4gICAgICBdLFxyXG4gICAgfSxcclxuICAgIGJlZm9yZTogYXBwID0+IHtcclxuICAgICAgLy8gU2VydmUgdGhlIHNpdGUgZGF0YVxyXG4gICAgICBhcHAuZ2V0KCcvX19yZWFjdC1zdGF0aWNfXy9nZXRNZXNzYWdlUG9ydCcsIGFzeW5jIChyZXEsIHJlcykgPT4ge1xyXG4gICAgICAgIHJlcy5zZW5kKHtcclxuICAgICAgICAgIHBvcnQ6IG1lc3NhZ2VQb3J0LFxyXG4gICAgICAgIH0pXHJcbiAgICAgIH0pXHJcbiAgICAgIC8vIFNpbmNlIHJvdXRlcyBtYXkgY2hhbmdlIGR1cmluZyBkZXYsIHRoaXMgZnVuY3Rpb24gY2FuIHJlYnVpbGQgYWxsIG9mIHRoZSBjb25maWdcclxuICAgICAgLy8gcm91dGVzLiBJdCBhbHNvIHJlZmVyZW5jZXMgdGhlIG9yaWdpbmFsIGNvbmZpZyB3aGVuIHBvc3NpYmxlLCB0byBtYWtlIHN1cmUgaXRcclxuICAgICAgLy8gdXNlcyBhbnkgdXAgdG8gZGF0ZSBnZXREYXRhIGNhbGxiYWNrIGdlbmVyYXRlZCBmcm9tIG5ldyBvciByZXBsYWNlbWVudCByb3V0ZXMuXHJcbiAgICAgIGJ1aWxkRGV2Um91dGVzID0gYXN5bmMgbmV3U3RhdGUgPT4ge1xyXG4gICAgICAgIGxhdGVzdFN0YXRlID0gYXdhaXQgZmV0Y2hTaXRlRGF0YShuZXdTdGF0ZSlcclxuXHJcbiAgICAgICAgYXBwLmdldCgnL19fcmVhY3Qtc3RhdGljX18vc2l0ZURhdGEnLCBhc3luYyAocmVxLCByZXMsIG5leHQpID0+IHtcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJlcy5zZW5kKGxhdGVzdFN0YXRlLnNpdGVEYXRhKVxyXG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgIHJlcy5zdGF0dXMoNTAwKVxyXG4gICAgICAgICAgICByZXMuc2VuZChlcnIpXHJcbiAgICAgICAgICAgIG5leHQoZXJyKVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIC8vIFNlcnZlIGVhY2ggcm91dGVzIGRhdGFcclxuICAgICAgICBsYXRlc3RTdGF0ZS5yb3V0ZXMuZm9yRWFjaCgoeyBwYXRoOiByb3V0ZVBhdGggfSkgPT4ge1xyXG4gICAgICAgICAgYXBwLmdldChcclxuICAgICAgICAgICAgYC9fX3JlYWN0LXN0YXRpY19fL3JvdXRlSW5mby8ke2VuY29kZVVSSShcclxuICAgICAgICAgICAgICByb3V0ZVBhdGggPT09ICcvJyA/ICcnIDogcm91dGVQYXRoXHJcbiAgICAgICAgICAgICl9YCxcclxuICAgICAgICAgICAgYXN5bmMgKHJlcSwgcmVzLCBuZXh0KSA9PiB7XHJcbiAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHdlIGhhdmUgdGhlIG1vc3QgdXAgdG8gZGF0ZSByb3V0ZSBmcm9tIHRoZSBjb25maWcsIG5vdFxyXG4gICAgICAgICAgICAgIC8vIGFuIG91dCBvZiBkYXQgb2JqZWN0LlxyXG4gICAgICAgICAgICAgIGxldCByb3V0ZSA9IGxhdGVzdFN0YXRlLnJvdXRlcy5maW5kKGQgPT4gZC5wYXRoID09PSByb3V0ZVBhdGgpXHJcbiAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGlmICghcm91dGUpIHtcclxuICAgICAgICAgICAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKFxyXG4gICAgICAgICAgICAgICAgICAgIGBSb3V0ZSBjb3VsZCBub3QgYmUgZm91bmQgZm9yOiAke3JvdXRlUGF0aH1cclxuICAgICAgICAgICAgICAgICAgICBcclxuSWYgeW91IHJlbW92ZWQgdGhpcyByb3V0ZSwgZGlzcmVnYXJkIHRoaXMgZXJyb3IuXHJcbklmIHRoaXMgaXMgYSBkeW5hbWljIHJvdXRlLCBjb25zaWRlciBhZGRpbmcgaXQgdG8gdGhlIHByZWZldGNoRXhjbHVkZXMgbGlzdDpcclxuXHJcbiAgYWRkUHJlZmV0Y2hFeGNsdWRlcyhbJyR7cm91dGVQYXRofSddKVxyXG5gXHJcbiAgICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgICAgICAgZGVsZXRlIGVyci5zdGFja1xyXG4gICAgICAgICAgICAgICAgICB0aHJvdyBlcnJcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByb3V0ZSA9IGF3YWl0IGdldFJvdXRlRGF0YShyb3V0ZSwgbGF0ZXN0U3RhdGUpXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRG9uJ3QgdXNlIGFueSBoYXNoUHJvcCwganVzdCBwYXNzIGFsbCB0aGUgZGF0YSBpbiBkZXZcclxuICAgICAgICAgICAgICAgIHJlcy5qc29uKHJvdXRlKVxyXG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICAgICAgcmVzLnN0YXR1cyg0MDQpXHJcbiAgICAgICAgICAgICAgICBuZXh0KGVycilcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIClcclxuICAgICAgICB9KVxyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMSkpXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGJ1aWxkRGV2Um91dGVzKHN0YXRlKVxyXG5cclxuICAgICAgaWYgKHN0YXRlLmNvbmZpZy5kZXZTZXJ2ZXIgJiYgc3RhdGUuY29uZmlnLmRldlNlcnZlci5iZWZvcmUpIHtcclxuICAgICAgICBzdGF0ZS5jb25maWcuZGV2U2VydmVyLmJlZm9yZShhcHApXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBhcHBcclxuICAgIH0sXHJcbiAgfVxyXG5cclxuICBsZXQgZmlyc3QgPSB0cnVlXHJcbiAgY29uc3Qgc3RhcnRlZEF0ID0gRGF0ZS5ub3coKVxyXG4gIGxldCBza2lwTG9nID0gZmFsc2VcclxuXHJcbiAgY29uc29sZS5sb2coJ0J1bmRsaW5nIEFwcGxpY2F0aW9uLi4uJylcclxuICB0aW1lKGNoYWxrLmdyZWVuKCdbXFx1MjcxM10gQXBwbGljYXRpb24gQnVuZGxlZCcpKVxyXG5cclxuICBkZXZDb21waWxlci5ob29rcy5pbnZhbGlkLnRhcChcclxuICAgIHtcclxuICAgICAgbmFtZTogJ1JlYWN0LVN0YXRpYycsXHJcbiAgICB9LFxyXG4gICAgKGZpbGUsIGNoYW5nZWQpID0+IHtcclxuICAgICAgLy8gSWYgYSBmaWxlIGlzIGNoYW5nZWQgd2l0aGluIHRoZSBmaXJzdCB0d28gc2Vjb25kcyBvZlxyXG4gICAgICAvLyB0aGUgc2VydmVyIHN0YXJ0aW5nLCB3ZSBkb24ndCBiYXJrIGFib3V0IGl0LiBMZXNzXHJcbiAgICAgIC8vIG5vaXNlIGlzIGJldHRlciFcclxuICAgICAgc2tpcExvZyA9IGNoYW5nZWQgLSBzdGFydGVkQXQgPCAyMDAwXHJcbiAgICAgIGlmICghc2tpcExvZykge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdGaWxlIGNoYW5nZWQ6JywgZmlsZS5yZXBsYWNlKHN0YXRlLmNvbmZpZy5wYXRocy5ST09ULCAnJykpXHJcbiAgICAgICAgY29uc29sZS5sb2coJ1VwZGF0aW5nIGJ1bmRsZS4uLicpXHJcbiAgICAgICAgdGltZShjaGFsay5ncmVlbignW1xcdTI3MTNdIEJ1bmRsZSBVcGRhdGVkJykpXHJcbiAgICAgIH1cclxuICAgIH1cclxuICApXHJcblxyXG4gIGRldkNvbXBpbGVyLmhvb2tzLmRvbmUudGFwKFxyXG4gICAge1xyXG4gICAgICBuYW1lOiAnUmVhY3QtU3RhdGljJyxcclxuICAgIH0sXHJcbiAgICBzdGF0cyA9PiB7XHJcbiAgICAgIGNvbnN0IG1lc3NhZ2VzID0gc3RhdHMudG9Kc29uKHt9LCB0cnVlKVxyXG4gICAgICBjb25zdCBpc1N1Y2Nlc3NmdWwgPSAhbWVzc2FnZXMuZXJyb3JzLmxlbmd0aCAmJiAhbWVzc2FnZXMud2FybmluZ3MubGVuZ3RoXHJcblxyXG4gICAgICBpZiAoaXNTdWNjZXNzZnVsICYmICFza2lwTG9nKSB7XHJcbiAgICAgICAgaWYgKGZpcnN0KSB7XHJcbiAgICAgICAgICB0aW1lRW5kKGNoYWxrLmdyZWVuKCdbXFx1MjcxM10gQXBwbGljYXRpb24gQnVuZGxlZCcpKVxyXG4gICAgICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgICAgIGAke2NoYWxrLmdyZWVuKCdbXFx1MjcxM10gQXBwIHNlcnZpbmcgYXQnKX0gJHtjaGFsay5ibHVlKFxyXG4gICAgICAgICAgICAgIGAke3N0YXRlLmNvbmZpZy5kZXZTZXJ2ZXIuaG9zdH06JHtzdGF0ZS5jb25maWcuZGV2U2VydmVyLnBvcnR9YFxyXG4gICAgICAgICAgICApfWBcclxuICAgICAgICAgIClcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGltZUVuZChjaGFsay5ncmVlbignW1xcdTI3MTNdIEJ1bmRsZSBVcGRhdGVkJykpXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBmaXJzdCA9IGZhbHNlXHJcbiAgICB9XHJcbiAgKVxyXG5cclxuICAvLyBTdGFydCB0aGUgd2VicGFjayBkZXYgc2VydmVyXHJcbiAgZGV2U2VydmVyID0gbmV3IFdlYnBhY2tEZXZTZXJ2ZXIoZGV2Q29tcGlsZXIsIGRldlNlcnZlckNvbmZpZylcclxuXHJcbiAgLy8gU3RhcnQgdGhlIG1lc3NhZ2VzIHNvY2tldFxyXG4gIGNvbnN0IHNvY2tldCA9IGlvKClcclxuXHJcbiAgcmVsb2FkQ2xpZW50RGF0YS5jdXJyZW50ID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgc29ja2V0LmVtaXQoJ21lc3NhZ2UnLCB7IHR5cGU6ICdyZWxvYWRDbGllbnREYXRhJyB9KVxyXG4gIH1cclxuXHJcbiAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgZGV2U2VydmVyLmxpc3Rlbihwb3J0LCBudWxsLCBlcnIgPT4ge1xyXG4gICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpXHJcbiAgICAgIH1cclxuICAgICAgcmVzb2x2ZSgpXHJcbiAgICB9KVxyXG4gIH0pXHJcblxyXG4gIC8vIE1ha2Ugc3VyZSB3ZSBzdGFydCBsaXN0ZW5pbmcgb24gdGhlIG1lc3NhZ2UgcG9ydCBhZnRlciB0aGUgZGV2IHNlcnZlci5cclxuICAvLyBXZSBkbyB0aGlzIG1vc3RseSB0byBhcHBlYXNlIGNvZGVzYW5kYm94LmlvLCBzaW5jZSB0aGV5IGF1dG9iaW5kIHRvIHRoZSBmaXJzdFxyXG4gIC8vIHBvcnQgdGhhdCBvcGVucyB1cCBmb3IgdGhlaXIgcHJldmlldyB3aW5kb3cuXHJcbiAgc29ja2V0Lmxpc3RlbihtZXNzYWdlUG9ydClcclxuXHJcbiAgc3RhdGUgPSBhd2FpdCBwbHVnaW5zLmFmdGVyRGV2U2VydmVyU3RhcnQoc3RhdGUpXHJcblxyXG4gIHJldHVybiBzdGF0ZVxyXG59XHJcbiJdfQ==